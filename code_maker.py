import path_maker
import string_manip
import name_maker
import strings

def code_cpp(self,tp):
    if(tp==strings.tp_main or tp==strings.tp_bf):
        return ('#include <bits/stdc++.h>\n'
                '\n'
                'using namespace std;\n'
                'typedef long long ll;\n'
                '\n'
                'int main()\n'
                '{\n'
                '    ios::sync_with_stdio(0);\n'
                '    cin.tie(0);\n'
                '    \n'
                '    return 0;\n'
                '}\n')
    elif(tp==strings.tp_ch):
        return ('#include <bits/stdc++.h>\n'
                '\n'
                'using namespace std;\n'
                '/*\n'
                'Input:\n'
                'gen.txt + main.txt\n'
                '\n'
                'Return:\n'
                'out_ok() if correct\n'
                'out_wa() if wrong\n'
                'Do NOT print anything else\n'
                '*/\n'
                'void out_ok() {exit(0);}\n'
                'void out_wa(string s="") {if(s=="") s="No response"; cout << s << "\\n"; exit(0);}\n'
                '\n'
                'int main()\n'
                '{\n'
                '    ios::sync_with_stdio(0);\n'
                '    cin.tie(0);\n'
                '    \n'
                '    return 0;\n'
                '}\n')
    elif(tp==strings.tp_gen):
        return ('#include <bits/stdc++.h>\n'
                '\n'
                'using namespace std;\n'
                'typedef long long ll;\n'
                '\n'
                'mt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n'
                'mt19937_64 genll(chrono::steady_clock::now().time_since_epoch().count());\n'
                '\n'
                'int rng(int l,int r) {return uniform_int_distribution<int>(l,r)(gen);}\n'
                'll rngll(ll l,ll r) {return uniform_int_distribution<ll>(l,r)(genll);}\n'
                'void rng_shuffle(auto &v) {shuffle(v.begin(),v.end(),gen);}\n'
                '\n'
                'int main()\n'
                '{\n'
                '    ios::sync_with_stdio(0);\n'
                '    cin.tie(0);\n'
                '    \n'
                '    return 0;\n'
                '}\n')

def code_cbp(self,tp):
    return ('<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>\n'
            '<CodeBlocks_project_file>\n'
            '    <FileVersion major="1" minor="6" />\n'
            '    <Project>\n'
            '        <Option title="'+name_maker.name_problem_cbp(self,tp)[:-4]+'" />\n'
            '        <Option pch_mode="2" />\n'
            '        <Option compiler="gcc" />\n'
            '        <Build>\n'
            '            <Target title="Debug">\n'
            '                <Option output="bin/Debug/'+name_maker.name_problem_cbp(self,tp)[:-4]+'" prefix_auto="1" extension_auto="1" />\n'
            '                <Option object_output="obj/Debug/" />\n'
            '                <Option type="1" />\n'
            '                <Option compiler="gcc" />\n'
            '                <Compiler>\n'
            '                    <Add option="-g" />\n'
            '                </Compiler>\n'
            '            </Target>\n'
            '            <Target title="Release">\n'
            '                <Option output="bin/Release/'+name_maker.name_problem_cbp(self,tp)[:-4]+'" prefix_auto="1" extension_auto="1" />\n'
            '                <Option object_output="obj/Release/" />\n'
            '                <Option type="1" />\n'
            '                <Option compiler="gcc" />\n'
            '                <Compiler>\n'
            '                    <Add option="-O2" />\n'
            '                </Compiler>\n'
            '                <Linker>\n'
            '                    <Add option="-s" />\n'
            '                </Linker>\n'
            '            </Target>\n'
            '        </Build>\n'
            '        <Compiler>\n'
            '            <Add option="-Wall" />\n'
            '            <Add option="-fexceptions" />\n'
            '        </Compiler>\n'
            '        <Unit filename="'+name_maker.name_problem_cpp(self,tp)+'" />\n'
            '        <Extensions>\n'
            '            <lib_finder disable_auto="1" />\n'
            '        </Extensions>\n'
            '    </Project>\n'
            '</CodeBlocks_project_file>\n')

def code_run(self):
    return ('# $1 -> io_cnt\n'
            '# $2 -> tl\n'
            '# $3 -> verdict_only\n'
            'NoColor=\'\\033[0m\'\n'
            'BRed=\'\\033[1;31m\'\n'
            'BGreen=\'\\033[1;32m\'\n'
            'BYellow=\'\\033[1;33m\'\n'
            'BBlue=\'\\033[1;34m\'\n'
            'BPurple=\'\\033[1;35m\'\n'
            'BWhite=\'\\033[1;37m\'\n'
            'g++ -Wall -Wextra -Wshadow -std=c++17 '+string_manip.path_wsl_q(path_maker.path_problem_cpp_wsl(self,strings.tp_main))+' -o '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_main))+'\n'
            'for((i=1;i<=${1};i++))\n'
            'do\n'
            '    printf "${BWhite}[Test #${i}] "\n'
            '    { timeout ${2} '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_main))+' < "'+string_manip.path_wsl(path_maker.path_io(self))+'/'+self.problem_index+'_${i}'+'.in" > '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_main))+'; } &>'+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_main))+'\n'
            '    if((${?}==124))\n'
            '    then\n'
            '        printf "${BPurple}TLE${NoColor}\\n"\n'
            '    elif [[ -s '+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_main))+' ]]\n'
            '    then\n'
            '        printf "${BYellow}RTE${NoColor}\\n"\n'
            '    elif cmp -s <(tr -s [:space:] \' \' < <(cat <(printf " ") '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_main))+' <(printf " "))) <(tr -s [:space:] \' \' < <(cat <(printf " ") "'+string_manip.path_wsl(path_maker.path_io(self))+'/'+self.problem_index+'_${i}'+'.out" <(printf " ")))\n'
            '    then\n'
            '        printf "${BGreen}OK${NoColor}\\n"\n'
            '    else\n'
            '        printf "${BRed}WA${NoColor}\\n"\n'
            '        if((${3}==0))\n'
            '        then\n'
            '            printf "${BBlue}Input${NoColor}\\n"\n'
            '            echo "$(<"'+string_manip.path_wsl(path_maker.path_io(self))+'/'+self.problem_index+'_${i}'+'.in")"\n'
            '            printf "${BBlue}Received${NoColor}\\n"\n'
            '            echo "$(<'+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_main))+')"\n'
            '            printf "${BBlue}Expected${NoColor}\\n"\n'
            '            echo "$(<"'+string_manip.path_wsl(path_maker.path_io(self))+'/'+self.problem_index+'_${i}'+'.out")"\n'
            '        fi\n'
            '    fi\n'
            'done\n')

def code_stress(self):
    return ('# $1 -> stress_cnt\n'
            '# $2 -> tl\n'
            'NoColor=\'\\033[0m\'\n'
            'BRed=\'\\033[1;31m\'\n'
            'BGreen=\'\\033[1;32m\'\n'
            'BYellow=\'\\033[1;33m\'\n'
            'BBlue=\'\\033[1;34m\'\n'
            'BPurple=\'\\033[1;35m\'\n'
            'BWhite=\'\\033[1;37m\'\n'
            'g++ -Wall -Wextra -Wshadow -std=c++17 '+string_manip.path_wsl_q(path_maker.path_problem_cpp_wsl(self,strings.tp_main))+' -o '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_main))+'\n'
            'g++ -Wall -Wextra -Wshadow -std=c++17 '+string_manip.path_wsl_q(path_maker.path_problem_cpp_wsl(self,strings.tp_bf))+' -o '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_bf))+'\n'
            'g++ -Wall -Wextra -Wshadow -std=c++17 '+string_manip.path_wsl_q(path_maker.path_problem_cpp_wsl(self,strings.tp_gen))+' -o '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_gen))+'\n'
            '> '+string_manip.path_wsl_q(path_maker.path_utils_verdict(self))+'\n'
            'for((i=1;i<=${1};i++))\n'
            'do\n'
            '    { timeout ${2} '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_gen))+' > '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_gen))+'; } &>'+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_gen))+'\n'
            '    if((${?}==124))\n'
            '    then\n'
            '        printf "\\r${BWhite}[Stress #${i}] ${BPurple}TLE: gen${NoColor}\\n"\n'
            '        break\n'
            '    elif [[ -s '+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_gen))+' ]]\n'
            '    then\n'
            '        printf "\\r${BWhite}[Stress #${i}] ${BYellow}RTE: gen${NoColor}\\n"\n'
            '        break\n'
            '    fi\n'
            '    { timeout ${2} '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_bf))+' < '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_gen))+' > '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_bf))+'; } &>'+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_bf))+'\n'
            '    if((${?}==124))\n'
            '    then\n'
            '        printf "\\r${BWhite}[Stress #${i}] ${BPurple}TLE: bf${NoColor}\\n"\n'
            '        break\n'
            '    elif [[ -s '+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_bf))+' ]]\n'
            '    then\n'
            '        printf "\\r${BWhite}[Stress #${i}] ${BYellow}RTE: bf${NoColor}\\n"\n'
            '        break\n'
            '    fi\n'
            '    { timeout ${2} '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_main))+' < '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_gen))+' > '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_main))+'; } &>'+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_main))+'\n'
            '    if((${?}==124))\n'
            '    then\n'
            '        printf "\\r${BWhite}[Stress #${i}] ${BPurple}TLE${NoColor}\\n"\n'
            '        printf "TLE" > '+string_manip.path_wsl_q(path_maker.path_utils_verdict(self))+'\n'
            '        break\n'
            '    elif [[ -s '+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_main))+' ]]\n'
            '    then\n'
            '        printf "\\r${BWhite}[Stress #${i}] ${BYellow}RTE${NoColor}\\n"\n'
            '        printf "RTE" > '+string_manip.path_wsl_q(path_maker.path_utils_verdict(self))+'\n'
            '        break\n'
            '    fi\n'
            '    if diff -q -b -B '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_main))+' '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_bf))+' &>/dev/null\n'
            '    then\n'
            '        printf "\\r${BWhite}[Stress #${i}] ${BGreen}OK${NoColor}"\n'
            '        printf "OK" > '+string_manip.path_wsl_q(path_maker.path_utils_verdict(self))+'\n'
            '        if((i==${1}))\n'
            '        then\n'
            '            printf "${NoColor}\\n"\n'
            '        fi\n'
            '    else\n'
            '        printf "\\r${BWhite}[Stress #${i}] ${BRed}WA${NoColor}\\n"\n'
            '        printf "${BBlue}Input${NoColor}\\n"\n'
            '        echo "$(<'+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_gen))+')"\n'
            '        printf "${BBlue}Received${NoColor}\\n"\n'
            '        echo "$(<'+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_main))+')"\n'
            '        printf "${BBlue}Expected${NoColor}\\n"\n'
            '        echo "$(<'+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_bf))+')"\n'
            '        printf "WA" > '+string_manip.path_wsl_q(path_maker.path_utils_verdict(self))+'\n'
            '        break\n'
            '    fi\n'
            'done\n')

def code_check(self):
    return ('# $1 -> check_cnt\n'
            '# $2 -> tl\n'
            'NoColor=\'\\033[0m\'\n'
            'BRed=\'\\033[1;31m\'\n'
            'BGreen=\'\\033[1;32m\'\n'
            'BYellow=\'\\033[1;33m\'\n'
            'BBlue=\'\\033[1;34m\'\n'
            'BPurple=\'\\033[1;35m\'\n'
            'BWhite=\'\\033[1;37m\'\n'
            'g++ -Wall -Wextra -Wshadow -std=c++17 '+string_manip.path_wsl_q(path_maker.path_problem_cpp_wsl(self,strings.tp_main))+' -o '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_main))+'\n'
            'g++ -Wall -Wextra -Wshadow -std=c++17 '+string_manip.path_wsl_q(path_maker.path_problem_cpp_wsl(self,strings.tp_ch))+' -o '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_ch))+'\n'
            'g++ -Wall -Wextra -Wshadow -std=c++17 '+string_manip.path_wsl_q(path_maker.path_problem_cpp_wsl(self,strings.tp_gen))+' -o '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_gen))+'\n'
            '> '+string_manip.path_wsl_q(path_maker.path_utils_verdict(self))+'\n'
            'for((i=1;i<=${1};i++))\n'
            'do\n'
            '    { timeout ${2} '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_gen))+' > '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_gen))+'; } &>'+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_gen))+'\n'
            '    if((${?}==124))\n'
            '    then\n'
            '        printf "\\r${BWhite}[Check #${i}] ${BPurple}TLE: gen${NoColor}\\n"\n'
            '        break\n'
            '    elif [[ -s '+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_gen))+' ]]\n'
            '    then\n'
            '        printf "\\r${BWhite}[Check #${i}] ${BYellow}RTE: gen${NoColor}\\n"\n'
            '        break\n'
            '    fi\n'
            '    { timeout ${2} '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_main))+' < '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_gen))+' > '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_main))+'; } &>'+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_main))+'\n'
            '    if((${?}==124))\n'
            '    then\n'
            '        printf "\\r${BWhite}[Check #${i}] ${BPurple}TLE${NoColor}\\n"\n'
            '        printf "TLE" > '+string_manip.path_wsl_q(path_maker.path_utils_verdict(self))+'\n'
            '        break\n'
            '    elif [[ -s '+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_main))+' ]]\n'
            '    then\n'
            '        printf "\\r${BWhite}[Check #${i}] ${BYellow}RTE${NoColor}\\n"\n'
            '        printf "RTE" > '+string_manip.path_wsl_q(path_maker.path_utils_verdict(self))+'\n'
            '        break\n'
            '    fi\n'
            '    { timeout ${2} '+string_manip.path_wsl_q(path_maker.path_problem_exe(self,strings.tp_ch))+' < <(cat '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_gen))+' '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_main))+') > '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_ch))+'; } &>'+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_ch))+'\n'
            '    if((${?}==124))\n'
            '    then\n'
            '        printf "\\r${BWhite}[Check #${i}] ${BPurple}TLE: ch${NoColor}\\n"\n'
            '        break\n'
            '    elif [[ -s '+string_manip.path_wsl_q(path_maker.path_utils_err(self,strings.tp_ch))+' ]]\n'
            '    then\n'
            '        printf "\\r${BWhite}[Check #${i}] ${BYellow}RTE: ch${NoColor}\\n"\n'
            '        break\n'
            '    fi\n'
            '    if [[ ! -s '+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_ch))+' ]]\n'
            '    then\n'
            '        printf "\\r${BWhite}[Check #${i}] ${BGreen}OK${NoColor}"\n'
            '        printf "OK" > '+string_manip.path_wsl_q(path_maker.path_utils_verdict(self))+'\n'
            '        if((i==${1}))\n'
            '        then\n'
            '            printf "${NoColor}\\n"\n'
            '        fi\n'
            '    else\n'
            '        printf "\\r${BWhite}[Check #${i}] ${BRed}WA${NoColor}\\n"\n'
            '        printf "${BBlue}Input${NoColor}\\n"\n'
            '        echo "$(<'+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_gen))+')"\n'
            '        printf "${BBlue}Received${NoColor}\\n"\n'
            '        echo "$(<'+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_main))+')"\n'
            '        printf "${BBlue}Checker Log${NoColor}\\n"\n'
            '        echo "$(<'+string_manip.path_wsl_q(path_maker.path_io_txt(self,strings.tp_ch))+')"\n'
            '        printf "WA" > '+string_manip.path_wsl_q(path_maker.path_utils_verdict(self))+'\n'
            '        break\n'
            '    fi\n'
            'done\n')
